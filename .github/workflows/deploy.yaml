# CI/CD Pipeline: Automates Entire Infra, App, Monitoring Stack. 
name: Deploy to GKE Cluster

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]
  workflow_dispatch:

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  REGISTRY: us-central1-docker.pkg.dev
  REPOSITORY: fastapi-app
  IMAGE_NAME: fastapi
  DB_USER_SECRET: ${{ secrets.DB_USER_SECRET }}
  DB_PASSWORD_SECRET: ${{ secrets.DB_PASSWORD_SECRET }}
  GKE_ZONE: ${{ secrets.GKE_ZONE }}

jobs:
  terraform:
    name: Terraform Infrastructure
    runs-on: ubuntu-latest
    if: (contains(github.event.head_commit.message, '[infra]') || github.event_name == 'workflow_dispatch') && github.event_name != 'pull_request'
    steps:
    - uses: actions/checkout@v4
    - uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
    - uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    - uses: google-github-actions/setup-gcloud@v2
    - name: Terraform Init
      working-directory: ./terraform
      run: terraform init
    - name: Terraform Plan
      working-directory: ./terraform
      env:
        TF_LOG: TRACE
        TF_VAR_project_id: ${{ secrets.GCP_PROJECT_ID }}
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD_SECRET }}
        TF_VAR_db_user: ${{ secrets.DB_USER_SECRET }}
        TF_VAR_zone: ${{ secrets.GKE_ZONE }}
      run: terraform plan -out=tfplan
    - name: Terraform Apply
      working-directory: ./terraform
      if: github.ref == 'refs/heads/main'
      env:
        TF_LOG: TRACE
        TF_VAR_project_id: ${{ secrets.GCP_PROJECT_ID }}
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD_SECRET }}
        TF_VAR_db_user: ${{ secrets.DB_USER_SECRET }}
        TF_VAR_zone: ${{ secrets.GKE_ZONE }}
      run: terraform apply -auto-approve tfplan

  build-push:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: terraform
    if: always() && (needs.terraform.result == 'success' || needs.terraform.result == 'skipped') && github.event_name != 'pull_request'
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}
    steps:
    - uses: actions/checkout@v4
    - uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    - uses: google-github-actions/setup-gcloud@v2
    - name: Configure Docker
      run: gcloud auth configure-docker ${{ env.REGISTRY }}
    - name: Build and Push
      id: build
      working-directory: ./app
      run: |
        TAG="${GITHUB_SHA::8}"
        URI="${REGISTRY}/${PROJECT_ID}/${REPOSITORY}/${IMAGE_NAME}:${TAG}"
        docker build -t "$URI" .
        docker push "$URI"
        if [ "$GITHUB_REF" = "refs/heads/main" ]; then
          docker tag "$URI" "${REGISTRY}/${PROJECT_ID}/${REPOSITORY}/${IMAGE_NAME}:latest"
          docker push "${REGISTRY}/${PROJECT_ID}/${REPOSITORY}/${IMAGE_NAME}:latest"
        fi
        echo "image-tag=$TAG" >> $GITHUB_OUTPUT

  deploy-app:
    name: Deploy FastAPI App
    runs-on: ubuntu-latest
    needs: [terraform, build-push, deploy-monitoring]
    if: always() && needs.build-push.result == 'success' && github.event_name != 'pull_request'
    steps:
    - uses: actions/checkout@v4
    - uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    - uses: google-github-actions/setup-gcloud@v2
    - run: gcloud components install gke-gcloud-auth-plugin
    - name: Get GKE Credentials
      run: gcloud container clusters get-credentials ${{ secrets.GKE_CLUSTER_NAME }} --zone ${{ secrets.GKE_ZONE }} --project ${{ secrets.GCP_PROJECT_ID }}
    - uses: azure/setup-helm@v3
      with:
        version: '3.12.0'
    - name: Helm Deploy
      run: |
        helm upgrade --install fastapi-app ./helm/fastapi-app \
          --set image.repository="${REGISTRY}/${PROJECT_ID}/${REPOSITORY}/${IMAGE_NAME}" \
          --set image.tag="${{ needs.build-push.outputs.image-tag }}" \
          --set image.pullPolicy=Always \
          --set service.type=LoadBalancer \
          --set service.port=80 \
          --set service.targetPort=8000 \
          --set service.metricsPort=8000 \
          --namespace default \
          --wait --timeout=300s
    - name: Verify App
      run: |
        kubectl delete pod -l app.kubernetes.io/name=fastapi-app --field-selector=status.phase=Succeeded || true
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=fastapi-app --timeout=300s

  deploy-monitoring:
    name: Deploy Monitoring
    runs-on: ubuntu-latest
    needs: terraform
    if: always() && (needs.terraform.result == 'success' || needs.terraform.result == 'skipped') && github.event_name != 'pull_request'
    steps:
    - uses: actions/checkout@v4
    - uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    - uses: google-github-actions/setup-gcloud@v2
    - run: gcloud components install gke-gcloud-auth-plugin
    - name: Get GKE Credentials
      run: gcloud container clusters get-credentials ${{ secrets.GKE_CLUSTER_NAME }} --zone ${{ secrets.GKE_ZONE }} --project ${{ secrets.GCP_PROJECT_ID }}
    - uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Create Monitoring Namespace
      run: |
        kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -

    - name: Create Slack Secret
      run: |
        kubectl create secret generic slack-webhook \
          --from-literal=url=${{ secrets.SLACK_WEBHOOK_URL }} \
          --namespace monitoring --dry-run=client -o yaml | kubectl apply -f -

    - name: Create AlertManager Config Secret
      run: |
        kubectl create secret generic alertmanager-main \
          --from-file=alertmanager.yml=./monitoring/alertmanager.yml \
          --namespace monitoring \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy Prometheus Stack (Simple Config)
      run: |
        helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
        helm repo update
        helm upgrade --install monitoring prometheus-community/kube-prometheus-stack \
          --namespace monitoring \
          --set prometheus.prometheusSpec.serviceMonitorSelectorNilUsesHelmValues=false \
          --set grafana.adminPassword=${{ secrets.GRAFANA_ADMIN_PASSWORD }} \
          --set grafana.service.type=LoadBalancer \
          --set alertmanager.enabled=true \
          --set alertmanager.alertmanagerSpec.routePrefix=/ \
          --set alertmanager.alertmanagerSpec.storage.volumeClaimTemplate.spec.resources.requests.storage=10Gi \
          --wait --timeout=600s

    - name: Verify Basic Deployment
      run: |
        echo "--- Checking all pods ---"
        kubectl get pods -n monitoring
        
        echo "--- Checking AlertManager StatefulSet ---"
        kubectl get statefulsets -n monitoring
        
        # Wait for AlertManager to be ready
        kubectl wait --for=condition=ready statefulset/alertmanager-monitoring-kube-prometheus-alertmanager -n monitoring --timeout=300s
        
        echo "AlertManager basic deployment successful!"

    - name: Configure AlertManager with Slack
      run: |
        # Create AlertManager config with Slack integration
        cat > /tmp/alertmanager-config.yml << 'EOF'
        apiVersion: v1
        kind: Secret
        metadata:
          name: alertmanager-monitoring-kube-prometheus-alertmanager
          namespace: monitoring
        type: Opaque
        stringData:
          alertmanager.yml: |
            global:
              resolve_timeout: 5m
              slack_api_url: '${{ secrets.SLACK_WEBHOOK_URL }}'
            route:
              group_by: ['alertname', 'job']
              group_wait: 30s
              group_interval: 5m
              repeat_interval: 12h
              receiver: slack-default
              routes:
              - match:
                  severity: critical
                receiver: slack-critical
              - match:
                  severity: warning
                receiver: slack-default
            receivers:
            - name: slack-default
              slack_configs:
              - channel: "#alerts-general"
                send_resolved: true
                title: '[{{ .Status | toUpper }}] {{ .CommonLabels.alertname }}'
                text: '{{ range .Alerts }}*Alert:* {{ .Annotations.summary }}\n*Description:* {{ .Annotations.description }}\n*Severity:* {{ .Labels.severity }}\n*Instance:* {{ .Labels.instance }}\n{{ end }}'
            - name: slack-critical
              slack_configs:
              - channel: "#alerts-critical"
                send_resolved: true
                title: '[CRITICAL] {{ .CommonLabels.alertname }}'
                text: '{{ range .Alerts }}*Alert:* {{ .Annotations.summary }}\n*Description:* {{ .Annotations.description }}\n*Severity:* {{ .Labels.severity }}\n*Instance:* {{ .Labels.instance }}\n{{ end }}'
        EOF
        
        # Apply the new config
        kubectl apply -f /tmp/alertmanager-config.yml
        
        # Restart AlertManager to pick up new config
        kubectl rollout restart statefulset/alertmanager-monitoring-kube-prometheus-alertmanager -n monitoring
        kubectl rollout status statefulset/alertmanager-monitoring-kube-prometheus-alertmanager -n monitoring --timeout=300s

    - name: Final Verification
      run: |
        echo "--- Final status check ---"
        kubectl get pods -n monitoring
        
        # Test AlertManager API
        kubectl port-forward -n monitoring svc/monitoring-kube-prometheus-alertmanager 9093:9093 &
        PF_PID=$!
        sleep 10
        
        if curl --fail --max-time 10 http://localhost:9093/api/v2/status; then
          echo "✅ AlertManager is working!"
        else
          echo "❌ AlertManager API test failed"
          kubectl logs -n monitoring statefulset/alertmanager-monitoring-kube-prometheus-alertmanager --tail=20
        fi
        
        kill $PF_PID || true
        
  configure-monitoring:
    name: Configure Dashboards and Alerts
    runs-on: ubuntu-latest
    needs: [deploy-app, deploy-monitoring]
    if: always() && needs.deploy-monitoring.result == 'success' && github.event_name != 'pull_request'
    steps:
    - uses: actions/checkout@v4
    - uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    - uses: google-github-actions/setup-gcloud@v2
    - run: gcloud components install gke-gcloud-auth-plugin
    - name: Get GKE Credentials
      run: gcloud container clusters get-credentials ${{ secrets.GKE_CLUSTER_NAME }} --zone ${{ secrets.GKE_ZONE }} --project ${{ secrets.GCP_PROJECT_ID }}
    - name: Apply Grafana Dashboards
      run: |
        sudo apt-get update && sudo apt-get install -y yq
        if [ -d "./monitoring/dashboards" ]; then
          kubectl create configmap grafana-dashboards \
            --from-file=./monitoring/dashboards/ \
            --namespace monitoring \
            --dry-run=client -o yaml | yq '.metadata.labels.grafana_dashboard = "1"' | kubectl apply -f -
        fi
    - name: Apply Prometheus Alert Rules
      run: |
        if [ -d "./monitoring/alerts" ]; then
          kubectl apply -f ./monitoring/alerts/ -n monitoring
        fi
    - name: Create ServiceMonitor for FastAPI
      run: |
        cat <<EOF | kubectl apply -f -
        apiVersion: monitoring.coreos.com/v1
        kind: ServiceMonitor
        metadata:
          name: fastapi-metrics
          namespace: monitoring
        spec:
          selector:
            matchLabels:
              app: fastapi-app
          endpoints:
          - port: http
            path: /metrics
            interval: 30s
        EOF

  test-notify:
    name: Post-deployment Health Check
    runs-on: ubuntu-latest
    needs: [deploy-app, configure-monitoring]
    if: always() && github.event_name != 'pull_request'
    steps:
    - uses: actions/checkout@v4
    - uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    - uses: google-github-actions/setup-gcloud@v2
    - run: gcloud components install gke-gcloud-auth-plugin
    - name: Get GKE Credentials
      run: gcloud container clusters get-credentials ${{ secrets.GKE_CLUSTER_NAME }} --zone ${{ secrets.GKE_ZONE }} --project ${{ secrets.GCP_PROJECT_ID }}
    - name: Check FastAPI Health
      run: |
        IP=$(kubectl get svc fastapi-app -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        echo "Testing FastAPI at: http://$IP"
        curl -f http://$IP/health || echo "Health check failed"
    - name: Get Grafana URL
      run: |
        GRAFANA_IP=$(kubectl get svc monitoring-grafana -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        echo "Grafana available at: http://$GRAFANA_IP"
        echo "GRAFANA_URL=http://$GRAFANA_IP" >> $GITHUB_ENV
    - name: Slack Notification
      if: always()
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        text: |
          Deployment: ${{ job.status }}
          FastAPI App: ${{ needs.deploy-app.result }}
          Monitoring: ${{ needs.deploy-monitoring.result }}
          Config: ${{ needs.configure-monitoring.result }}
          Grafana: ${{ env.GRAFANA_URL }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}